"""
This is the main script that will be running the whole interview process.
Interview details are generated by the interview agent at the beginning based on job description and candidate details.
Interview agent generates the interview scenario and character details.
Interview agent only runs once. For now, we are not generating any information from it.
Activity agent generates activity details based on the interview details. It is also responsible for monitoring changes in the activity during the interview.
Activity can be coding or system design. For now, we are only supporting coding and the question is also predetermined.
Master agent is responsible for conducting the whole interview.
Master agent manages the whole interview including spinning off different agents and communicating with the frontend.
"""

import os

from fastapi import FastAPI, HTTPException, Request, Response, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from globals import config, main_logger
from providers.provider_factory import ProviderFactory
from routers.applications import router as applications_router
from routers.candidates import router as candidates_router
from routers.company import router as company_router
from routers.demo_request import router as demo_request_router
from routers.evaluation import router as evaluation_router
from routers.interview_configuration import router as interview_configuration_router
from routers.job_postings import router as job_postings_router
from routers.upload_image import router as upload_image_router
from routers.video_chunk import router as video_chunk_router
from server.connection_manager import ConnectionManager
from server.server import WebSocketHandler
from server.user_master_instance_manager import UserMasterInstanceManager

# Create a FastAPI instance
app = FastAPI(
    title="Interview Simulation Platform",
    description="AI-powered interview simulation platform",
    debug=config.debug,
)

# Configure static files based on storage configuration
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
if config.storage.type == "local":
    static_path = config.storage.local_path or "./static"
    if not os.path.isabs(static_path):
        static_path = os.path.join(BASE_DIR, static_path.lstrip("./"))

    print(
        f"Mounting static folder: {static_path} (from config: storage.type={config.storage.type})"
    )
    app.mount("/static", StaticFiles(directory=static_path), name="static")
else:
    # For non-local storage (firebase, aws_s3), we still need a local static folder for temporary files
    static_path = os.path.join(BASE_DIR, "static")
    print(
        f"Using {config.storage.type} storage but mounting local static for temp files: {static_path}"
    )
    app.mount("/static", StaticFiles(directory=static_path), name="static")
# Globals or shared instances
websocket_connection_manager: ConnectionManager = ConnectionManager(main_logger)
user_master_instance_manager = UserMasterInstanceManager()
websocket_handler = None

app.add_middleware(
    CORSMiddleware,
    allow_origins=config.security.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(demo_request_router)
app.include_router(video_chunk_router)
app.include_router(upload_image_router)
app.include_router(evaluation_router)
app.include_router(interview_configuration_router)
app.include_router(company_router)
app.include_router(candidates_router)
app.include_router(job_postings_router)
app.include_router(applications_router)


@app.options("/summary/{company_name}")
def preflight_summary(company_name: str, request: Request):
    response = Response()
    response.headers["Access-Control-Allow-Origin"] = request.headers.get("origin", "*")
    response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS, PUT, DELETE"
    response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
    response.status_code = 204
    return response


@app.on_event("startup")
async def startup_event():
    global websocket_handler
    main_logger.info("Starting the server")
    main_logger.info(f"Environment: {config.environment}")
    main_logger.info(f"Database type: {config.database.type}")
    main_logger.info(f"Storage type: {config.storage.type}")
    main_logger.info(f"Debug mode: {config.debug}")
    main_logger.info(f"Log level: {config.log_level}")

    data_dir = os.path.dirname(os.path.realpath(__file__)) + "/data/"

    provider_factory = ProviderFactory()
    all_providers = provider_factory.create_all_providers()
    websocket_handler = WebSocketHandler(
        websocket_connection_manager, user_master_instance_manager, data_dir, all_providers
    )

    for route in app.routes:
        main_logger.info(f"Path: {route.path}, Name: {route.name}, Type: {type(route).__name__}")


@app.get("/")
async def root():
    return {"message": "Hello World"}


# Websocket endpoint for communication with the frontend. This is triggered once the user logs in.
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    global websocket_handler
    if websocket_handler is None:
        raise HTTPException(status_code=500, detail="WebSocket handler not initialized")
    await websocket_handler.handle_websocket(websocket)


# if __name__ == "__main__":

#     data_dir = os.path.dirname(os.path.realpath(__file__)) + "/data/"
#     main_logger = logger_manager.get_main_logger()
#     main_logger.info("Starting the server")

#     websocket_connection_manager = ConnectionManager(main_logger)
#     llm_provider = _configure_openai_provider()
#     gemini_provider = _configure_gemini_provider()
#     groq_provider = _configure_groq_provider()
#     grok_provider = _configure_grok_provider()
#     deepseek_provider = _configure_deepseek_provider()

#     master_instances = {}
#     last_message_tracker = {}

#     for route in app.routes:
#         main_logger.info(f"Path: {route.path}, Name: {route.name}, Type: {type(route).__name__}")

#     asyncio.run(start_websocket(app))
